<!DOCTYPE html>
<html lang="hi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Live School Route Tracker</title>

<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  integrity="sha256-sA+e2k3s5f1gY0Gq4kqv9gq0kF5k7b9gq5p3gkXQk0M=" crossorigin=""/>

<style>
  body{font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans", sans-serif; margin:0; padding:0;}
  #topbar{padding:12px; background:#1473e6; color:white; display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
  #topbar h1{font-size:16px; margin:0;}
  .btn{background:#ffffff22; color:white; border:0; padding:8px 10px; border-radius:6px; cursor:pointer;}
  .btn:active{transform:translateY(1px);}
  #statusSmall{font-size:13px; opacity:0.95; margin-left:auto; color:#fff; }
  #map{height:60vh; min-height:360px;}
  #panels{display:flex; gap:12px; padding:12px; flex-wrap:wrap; }
  .card{background:#fff; border-radius:8px; box-shadow:0 2px 6px rgba(0,0,0,0.08); padding:12px; flex:1; min-width:260px;}
  .small{font-size:13px; color:#333;}
  .ok{color:green; font-weight:700;}
  .no{color:red; font-weight:700;}
  pre{background:#f7f7f7; padding:10px; border-radius:6px; overflow:auto; max-height:120px;}
  .accuracy-info{font-size:13px; color:#555; margin-top:6px;}
  .center-list{margin-top:6px;}
  .center-item{display:flex; gap:8px; align-items:center; margin-bottom:6px;}
  .center-item strong{flex:1;}
  .dot{display:inline-block;width:10px;height:10px;border-radius:50%;}
  #insideSection{display:none; padding:12px; border-radius:8px; background:#f0fff4; margin-top:8px; border:1px solid #b7f0c6;}
  /* small responsive */
  @media (max-width:720px){ #panels{flex-direction:column;} #topbar{gap:6px;} }
</style>
</head>
<body>

<div id="topbar">
  <h1>School Live Route Tracker (Leaflet + OSRM)</h1>
  <button id="btnStart" class="btn">üìç Start Live Tracking</button>
  <button id="btnStop" class="btn" style="display:none;background:#ff6b6b;">‚èπÔ∏è Stop</button>
  <button id="btnManual" class="btn">üñäÔ∏è Manual Set</button>
  <div id="statusSmall">Ready ‚Äî "Start Live Tracking" ‡§¶‡§¨‡§æ‡§è‡§Å ‡§Ø‡§æ manual set ‡§ï‡§∞‡•á‡§Ç‡•§</div>
</div>

<div id="map"></div>

<div id="panels">
  <div class="card">
    <div class="small"><strong>Position & Accuracy</strong></div>
    <div id="posInfo" class="small" style="margin-top:8px;">No position yet.</div>
    <div id="accuracyInfo" class="accuracy-info" style="display:none;">
      Accuracy: <span id="accVal"></span> meters
    </div>
    <div id="insideSection">
      <div id="insideMsg" class="ok">‡§Ü‡§™ ‡§ö‡•Å‡§®‡•á ‡§π‡•Å‡§è school ‡§ï‡•á ‡§Ö‡§Ç‡§¶‡§∞ ‡§π‡•à‡§Ç‡•§</div>
      <div id="insideDetails" class="small"></div>
    </div>
  </div>

  <div class="card">
    <div class="small"><strong>Schools (edit radius)</strong></div>
    <div class="center-list" id="centerList"></div>
    <div style="margin-top:8px;">
      <label class="small"><input type="checkbox" id="followUser" checked> Map follow user</label>
    </div>
  </div>

  <div class="card">
    <div class="small"><strong>Distances (live)</strong></div>
    <div style="margin-top:8px;">
      <div id="d1" class="small">Sarasvati School: ‚Äî</div>
      <div id="d2" class="small" style="margin-top:6px;">Government School: ‚Äî</div>
    </div>

    <div style="margin-top:8px;">
      <div class="small"><strong>Debug</strong></div>
      <pre id="debug">Ready.</pre>
    </div>
  </div>
</div>

<!-- Manual modal-like inputs (simple) -->
<div id="manualContainer" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.35); align-items:center; justify-content:center;">
  <div style="background:white; padding:14px; border-radius:8px; width:320px;">
    <h3 style="margin:0 0 10px 0;">Manual Location Set</h3>
    <label class="small">Latitude</label>
    <input id="manLat" type="number" step="any" style="width:100%; padding:8px; box-sizing:border-box; margin-top:6px;">
    <label class="small" style="margin-top:8px;">Longitude</label>
    <input id="manLon" type="number" step="any" style="width:100%; padding:8px; box-sizing:border-box; margin-top:6px;">
    <div style="display:flex; gap:8px; margin-top:10px; justify-content:flex-end;">
      <button id="manCancel" class="btn" style="background:#ddd;color:#000;">Cancel</button>
      <button id="manSave" class="btn">Set</button>
    </div>
  </div>
</div>

<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-o9N1jKQbJ+vG0y2gX/2jz0bPj1bKPs6b1gW+6bM1f0k=" crossorigin=""></script>

<script>
/*
  Full single-file implementation:
  - Live watchPosition (fallback to manual)
  - Leaflet map with user marker (moving)
  - Two school markers
  - Driving route (OSRM) polylines from user to each school (red)
  - Distances updated live (driving distance when OSRM available; else haversine)
  - Debounce route requests to avoid too many calls while moving
  - All in-page (no server side)
*/

/* --- CONFIG --- */
const centers = [
  { name: 'Sarasvati School', lat: 24.6832581, lon: 80.5419671, radiusKm: 1 },
  { name: 'Government School', lat: 24.6835231, lon: 80.5439499, radiusKm: 1 }
];

// OSRM routing base - using routing.openstreetmap.de (public)
const OSRM_BASE = 'https://routing.openstreetmap.de/routed-car/route/v1/driving';

/* --- STATE --- */
let map, userMarker, accuracyCircle;
let centerMarkers = [];
let routeLayers = []; // polyline layers for each center
let watchId = null;
let lastRouteRequest = 0;
const ROUTE_MIN_INTERVAL_MS = 2500; // at least 2.5s between route requests
let lastPos = null;

/* --- Helpers --- */
function toFixedCoords(v){ return (Math.round(v*1e6)/1e6); }
function haversineKm(lat1,lon1,lat2,lon2){
  const R=6371;
  const toRad=deg=>deg*Math.PI/180;
  const dLat=toRad(lat2-lat1);
  const dLon=toRad(lon2-lon1);
  const a=Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
  const c=2*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R*c;
}
function fmtDistanceKm(dKm){
  if (dKm < 1) return `${Math.round(dKm*1000)} meters`;
  return `${dKm.toFixed(2)} km`;
}

/* --- Map Init --- */
function initMap(){
  map = L.map('map', { zoomControl:true }).setView([centers[0].lat, centers[0].lon], 15);

  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  // Add center markers
  centers.forEach((c,i)=>{
    const m = L.marker([c.lat, c.lon], { title:c.name }).addTo(map);
    m.bindPopup(`<strong>${c.name}</strong><br>Radius: <span id="rad-${i}">${c.radiusKm}</span> km`);
    centerMarkers.push(m);
    // prepare empty polyline
    const poly = L.geoJSON(null, { style: { color: '#d32f2f', weight:4, opacity:0.85 } }).addTo(map);
    routeLayers.push(poly);
  });

  // user marker + accuracy circle
  userMarker = L.circleMarker([0,0], { radius:8, color:'#1473e6', fillColor:'#1473e6', fillOpacity:1 }).addTo(map);
  userMarker.bindPopup('User location');

  accuracyCircle = L.circle([0,0], { radius:0, color:'#1473e6', weight:1, fillOpacity:0.05 }).addTo(map);
  userMarker.setOpacity(0);

  // show center list with editable radius
  renderCenterList();
}

/* --- Render center radius editors --- */
function renderCenterList(){
  const el = document.getElementById('centerList');
  el.innerHTML = '';
  centers.forEach((c,i)=>{
    const div = document.createElement('div');
    div.className = 'center-item';
    div.innerHTML = `
      <strong>${c.name}</strong>
      <input type="number" step="0.1" id="radInput-${i}" value="${c.radiusKm}" style="width:80px; padding:6px;">
      <button id="btnChk-${i}" class="btn" style="padding:6px;">Check</button>
    `;
    el.appendChild(div);

    document.getElementById(`btnChk-${i}`).addEventListener('click', ()=>{
      if (!lastPos) { alert('Pehele location set karein (Start Live Tracking ya Manual Set).'); return; }
      checkInside(lastPos.lat, lastPos.lon, i);
    });

    document.getElementById(`radInput-${i}`).addEventListener('change', (e)=>{
      const v = parseFloat(e.target.value);
      if (!isNaN(v)) {
        centers[i].radiusKm = v;
        document.getElementById(`rad-${i}`).textContent = v;
      }
    });
  });
}

/* --- Check if inside center radius using driving distance if available else haversine --- */
async function checkInside(userLat, userLon, centerIdx){
  const center = centers[centerIdx];
  // try driving distance first (OSRM)
  const dist = await getDrivingDistance(userLat,userLon, center.lat, center.lon);
  const inside = dist <= center.radiusKm + 1e-9;
  const msg = `${center.name}: ${fmtDistanceKm(dist)} ‚Äî radius ${center.radiusKm} km`;
  const resEl = document.getElementById('posInfo');
  if (inside){
    document.getElementById('insideSection').style.display = 'block';
    document.getElementById('insideDetails').textContent = msg;
    resEl.innerHTML = `<span class="ok">‚úÖ ${msg} ‚Üí ‡§Ö‡§Ç‡§¶‡§∞ ‡§π‡•à</span>`;
  } else {
    document.getElementById('insideSection').style.display = 'none';
    resEl.innerHTML = `<span class="no">‚ùå ${msg} ‚Üí ‡§¨‡§æ‡§π‡§∞ ‡§π‡•à</span>`;
  }
}

/* --- OSRM Route fetch (returns {distanceKm, geojson}) --- */
async function fetchRouteGeojson(lat1,lon1,lat2,lon2){
  // build URL with overview=full & geometries=geojson
  const coords = `${lon1},${lat1};${lon2},${lat2}`;
  const url = `${OSRM_BASE}/${coords}?overview=full&geometries=geojson&steps=false`;
  try {
    const resp = await fetch(url);
    if (!resp.ok) throw new Error('network');
    const j = await resp.json();
    if (j.code === 'Ok' && j.routes && j.routes.length>0){
      const route = j.routes[0];
      return {
        distanceKm: route.distance / 1000,
        geojson: route.geometry // GeoJSON LineString
      };
    } else {
      // fallback to straight line distance
      return { distanceKm: haversineKm(lat1,lon1,lat2,lon2), geojson: null };
    }
  } catch (e){
    // network or CORS or other error
    return { distanceKm: haversineKm(lat1,lon1,lat2,lon2), geojson: null };
  }
}

/* --- Request + draw routes for each center (debounced) --- */
async function updateRoutesAndDistances(userLat, userLon){
  const now = Date.now();
  if (now - lastRouteRequest < ROUTE_MIN_INTERVAL_MS) return;
  lastRouteRequest = now;

  // update each center route
  for (let i=0;i<centers.length;i++){
    try {
      const r = await fetchRouteGeojson(userLat,userLon, centers[i].lat, centers[i].lon);
      // update distance display
      const distEl = document.getElementById(i===0?'d1':'d2');
      distEl.textContent = `${centers[i].name}: ${fmtDistanceKm(r.distanceKm)}`;

      // update polyline layer
      routeLayers[i].clearLayers();
      if (r.geojson){
        // GeoJSON LineString -> add to layer
        routeLayers[i].addData(r.geojson);
        // ensure style (red) is applied via options earlier
      } else {
        // no route geometry -> draw simple straight line
        const line = {
          "type":"Feature",
          "geometry": {
            "type":"LineString",
            "coordinates": [
              [userLon, userLat],
              [centers[i].lon, centers[i].lat]
            ]
          }
        };
        routeLayers[i].addData(line);
      }

    } catch (e){
      console.error('route update error', e);
      document.getElementById('debug').textContent = 'Route error: '+e;
    }
  }

  // optionally zoom to show user + both centers
  if (document.getElementById('followUser').checked){
    try {
      const groupCoords = [
        [userLat, userLon],
        [centers[0].lat, centers[0].lon],
        [centers[1].lat, centers[1].lon]
      ];
      const bounds = L.latLngBounds(groupCoords);
      map.fitBounds(bounds.pad(0.25), { maxZoom: 17, animate: true });
    } catch(e){}
  }
}

/* --- Update user marker & UI --- */
function updateUserPosition(lat,lon,accuracy){
  lastPos = { lat, lon, accuracy };
  userMarker.setLatLng([lat,lon]);
  userMarker.setOpacity(1);
  userMarker.bindPopup(`You: ${toFixedCoords(lat)}, ${toFixedCoords(lon)} <br>Acc: ${Math.round(accuracy)} m`);
  accuracyCircle.setLatLng([lat,lon]);
  accuracyCircle.setRadius(Math.max(accuracy, 8));
  document.getElementById('posInfo').textContent = `Latitude: ${toFixedCoords(lat)}, Longitude: ${toFixedCoords(lon)}`;
  document.getElementById('accVal').textContent = `${Math.round(accuracy)}`;
  document.getElementById('accuracyInfo').style.display = 'block';
  document.getElementById('debug').textContent = `Last pos: ${JSON.stringify(lastPos,null,2)}`;

  // update routes + distances (debounced inside)
  updateRoutesAndDistances(lat,lon);
}

/* --- Start / Stop geolocation watch --- */
function startWatch(){
  if (!navigator.geolocation){
    alert('Browser geolocation supported nahi hai. Manual set karo.');
    return;
  }
  if (watchId !== null) return;

  // set UI
  document.getElementById('statusSmall').textContent = 'Tracking... (moving marker will update routes)';
  document.getElementById('btnStart').style.display = 'none';
  document.getElementById('btnStop').style.display = 'inline-block';

  // use watchPosition for live updates
  watchId = navigator.geolocation.watchPosition(async (pos)=>{
    const lat = pos.coords.latitude;
    const lon = pos.coords.longitude;
    const acc = pos.coords.accuracy ?? 50;

    updateUserPosition(lat,lon,acc);

    // small map follow
    if (document.getElementById('followUser').checked){
      map.panTo([lat,lon], { animate:true, duration: 0.5 });
    }

  }, (err)=>{
    console.error('geo error', err);
    document.getElementById('statusSmall').textContent = 'GPS error: '+err.message;
    // keep watchId false; caller can use manual
  }, { enableHighAccuracy:true, maximumAge:1000, timeout:10000 });
}

function stopWatch(){
  if (watchId !== null){
    navigator.geolocation.clearWatch(watchId);
    watchId = null;
  }
  document.getElementById('statusSmall').textContent = 'Tracking stopped.';
  document.getElementById('btnStart').style.display = 'inline-block';
  document.getElementById('btnStop').style.display = 'none';
}

/* --- Manual set --- */
function showManual(){
  document.getElementById('manualContainer').style.display = 'flex';
}
function hideManual(){
  document.getElementById('manualContainer').style.display = 'none';
}
function setManual(){
  const lat = parseFloat(document.getElementById('manLat').value);
  const lon = parseFloat(document.getElementById('manLon').value);
  if (isNaN(lat) || isNaN(lon)){
    alert('Valid lat/lon daalein.');
    return;
  }
  // stop watch (so manual position isn't overwritten)
  stopWatch();
  updateUserPosition(lat,lon, 50);
  // center map to manual
  map.setView([lat,lon], 16);
  hideManual();
}

/* --- Event wiring --- */
document.getElementById('btnStart').addEventListener('click', ()=>startWatch());
document.getElementById('btnStop').addEventListener('click', ()=>stopWatch());
document.getElementById('btnManual').addEventListener('click', ()=>showManual());
document.getElementById('manCancel').addEventListener('click', ()=>hideManual());
document.getElementById('manSave').addEventListener('click', ()=>setManual());

/* --- Initialize --- */
initMap();
document.getElementById('debug').textContent = 'Map initialized. Click Start Live Tracking or Manual Set.';

/* --- Optional: On load, try 5s optimized capture (like your earlier code) THEN start watch if permission granted.
   We'll keep it simple: only start watch when user presses Start.
*/

/* --- Final note in debug --- */
console.log('Live School Route Tracker ready.');
</script>
</body>
</html>
